<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Scatters</title>
    <script type="text/javascript" src="js/d3.v4.js"></script>
    <script type="text/javascript" src="js/draw_L3.js"></script>
    <script type="text/javascript" src="js/data1.js"></script>
    <script type="text/javascript" src="js/data2.js"></script>
    <script type="text/javascript" src="js/data3.js"></script>

    <style type="text/css">
        .axis {
            fill: none;
            stroke: #000;
            shape-rendering: crispEdges;
        }

        .dot2 {
            fill: steelblue;
        }

        .zoom {
            fill: none;
            pointer-events: all;
        }

        #SNIAText {
            position: absolute;

        }

        #SNIAText.hidden {
            display: none;
        }

        #L3Img.hidden {
            display: none;
        }

        #L3Img {
            position: absolute;
            top: 25px;
            left: 25px;
            /* pointer-events: none; */
            opacity: 0.95;
        }
    </style>
</head>
<body>

<div id="SNIAText" class="hidden">
    <p>SNIA <span id="SNIAID">0</span></p>
</div>

<div id="L3Img" class="hidden" width="800" height="600">

</div>


<script>
    // true is scatter for M0 and x, false is scatter for M0 and c
    var M0_x = true;

    // svg attr
    var margin = {top: 40, right: 20, bottom: 20, left: 40};
    var width = 960;
    var height = 600;


    // create SVG element for drawing scatters
    var svg = d3.select("body")
            .append("svg")
            .attr("class", "svg")
            .attr("width", width)
            .attr("height", height);

    // scale functions
    var x = d3.scaleLinear()
            .domain([d3.min(data1, function(d) { return d.m_mu; }), d3.max(data1, function(d) { return d.m_mu; })])
            .range([0, width - 1]);
    var y = d3.scaleLinear()
            .domain([d3.min(data1, function(d) { return d.x; }), d3.max(data1, function(d) { return d.x; })])
            .range([height - 1, 0]);

    // x and y axis
    var xAxis = d3.axisTop(x);
    var yAxis = d3.axisRight(y);

    // create x and y axis
    var gx = svg.append("g")
            .attr("class", "axis")
            .attr("transform", "translate(0, " + (height - 1)+ ")")
            .call(xAxis);
    var gy = svg.append("g")
            .attr("class", "axis")
            .attr("transform", "translate(0, 0)")
            .call(yAxis);

    // define key function
    var key = function(d) {
        return d.key;
    }

    // group all data dots
    var g_dots = svg.append("g");

    // create data dots
    var circles = g_dots.selectAll("circle")
            .data(data1, key)
            .enter()
            .append("circle")
            .attr("class", "dot")
            .attr("cx", function(d) {
                return x(d.m_mu);
            })
            .attr("cy", function(d) {
                return y(d.x);
            })
            .attr("r", 8)
            .attr("stroke", function(d) {
                if (d.key >= 1 && d.key <= 10) {
                    return "yellow";
                } else {
                    return "none";
                }
            })
            .attr("fill", function(d) {
                var color = data2[d.key-1].color;
                var R = Math.floor((0.3 + color) * 255 / 0.6);
                var B = Math.floor((0.3 - color) * 255 / 0.6);
                if (d.key >= 0 && d.key <= 10) {
                    return "yellow";
                }
                return "rgb(" + R + ", 0, " + B + ")";
            })
            .on("mouseover", function(d) {
                d3.select("#SNIAText")
                        .style("left", (width + 100) + "px")
                        .style("top", 0 + "px")
                        .select("#SNIAID")
                        .text(d.key);

                d3.select("#SNIAText").classed("hidden", false);

            })
            .on("mouseout", function() {
                d3.select("#SNIAText").classed("hidden", true);
            })
            .on("click", function(d) {
                if (d3.select("#L3Img").attr("class") == "hidden") {
                    createLevel3Image(d.key);
                    d3.select("#L3Img").classed("hidden", false);
                }
            });

    // press key ESC to conceal L3Img
    d3.select("body")
            .on("keydown", function(d) {
                if (event.key == "Escape") {
                    d3.select("#L3Img").classed("hidden", true);
                    d3.select(".imgx").remove();
                }
            });

    // define zoom attr
    var zoom = d3.zoom()
            .scaleExtent([0.75, 20])
            .translateExtent([[-width/2, -height/2], [width*3/2, height*3/2]])
            .on("zoom", function() {
                // zoom g_dots group

                g_dots.attr("transform", d3.event.transform);
                circles.attr("r", 8 / d3.event.transform.k);

                gx.call(xAxis.scale(d3.event.transform.rescaleX(x)));
                gy.call(yAxis.scale(d3.event.transform.rescaleY(y)));

            });

    // create a rect for zooming
    svg.call(zm = zoom);

    // create a button for converting between the two scatters
    d3.select("body")
            .append("button")
            .text("turn")
            .on("click", function() {
                // convert between M0_x and M0_c, and change the dataset
                M0_x = !M0_x;

                if (M0_x) {
                    // redraw y axis
                    y.domain([d3.min(data1, function(d) { return d.x; }), d3.max(data1, function(d) { return d.x; })]);
                    gy.call(yAxis);

                    // redraw dots
                    g_dots.selectAll("circle")
                            .data(data1, key)
                            .attr("cx", function(d) {
                                return x(d.m_mu);
                            })
                            .attr("cy", function(d) {
                                return y(d.x);
                            });
                } else {
                    // redraw y axis
                    y.domain([d3.min(data1, function(d) { return d.c; }), d3.max(data1, function(d) { return d.c; })]);
                    gy.call(yAxis);

                    // redraw dots
                    g_dots.selectAll("circle")
                            .data(data1, key)
                            .attr("cx", function(d) {
                                return x(d.m_mu);
                            })
                            .attr("cy", function(d) {
                                return y(d.c);
                            });
                }

                //d3.selection.call(zoom.transform, d3.zoomIdentity);
                //d3.selection.call(zoom.scaleTo, d3.zoomIdentity);
            });

    // create image in level 3
    function createLevel3Image(SNid) {
        var imgx = document.createElement("img");
        imgx.setAttribute("src", "SNIa_pics/" + SNid + ".jpg");
        imgx.setAttribute("class", "imgx");
        imgx.setAttribute("width", 400);
        //imgx.setAttribute("height", 640);

        document.getElementById("L3Img").appendChild(imgx);
    }

    /*
    d3.select("body")
            .append("button")
            .text("turn")
            .on("click", function() {
                d3.transition()
                        .duration(250)
                        .tween("zoom", svg.call(zoom.translate([0, 0]).scale(1).event));
            });
    */
</script>
</body>
</html>