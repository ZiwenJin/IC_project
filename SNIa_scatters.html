<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Scatters</title>
    <script type="text/javascript" src="js/d3.v4.js"></script>
    <script type="text/javascript" src="js/data1.js"></script>
    <script type="text/javascript" src="js/data2.js"></script>

    <style type="text/css">
        .axis {
            fill: none;
            stroke: #000;
            shape-rendering: crispEdges;
        }

        .dot {
            fill: steelblue;
        }

        .zoom {
            fill: none;
            pointer-events: all;
        }

        #tooltip {
            position: absolute;

        }

        #tooltip.hidden {
            display: none;
        }
    </style>
</head>
<body>

<div id="tooltip" class="hidden">
    <p>SNIA <span>100</span></p>
</div>

<script>
    // true is scatter for M0 and x, false is scatter for M0 and c
    var M0_x = true;

    // svg attr
    var margin = {top: 40, right: 20, bottom: 20, left: 40};
    var width = 960;
    var height = 600;

    var regex = /[+-]?\d+(\.\d+)?/g;

    // create SVG element for drawing scatters
    var svg = d3.select("body")
            .append("svg")
            .attr("class", "svg")
            .attr("width", width)
            .attr("height", height);

    // scale functions
    var x = d3.scaleLinear()
            .domain([d3.min(data1, function(d) { return d.m_mu; }), d3.max(data1, function(d) { return d.m_mu; })])
            .range([0, width - 1]);
    var y = d3.scaleLinear()
            .domain([d3.min(data1, function(d) { return d.x; }), d3.max(data1, function(d) { return d.x; })])
            .range([height - 1, 0]);

    // x and y axis
    var xAxis = d3.axisTop(x);
    var yAxis = d3.axisRight(y);

    // create x and y axis
    var gx = svg.append("g")
            .attr("class", "axis")
            .attr("transform", "translate(0, " + (height - 1)+ ")")
            .call(xAxis);
    var gy = svg.append("g")
            .attr("class", "axis")
            .attr("transform", "translate(0, 0)")
            .call(yAxis);

    // define key function
    var key = function(d) {
        return d.key;
    }

    // group all data dots
    var g_dots = svg.append("g");

    // create data dots
    var circles = g_dots.selectAll("circle")
            .data(data1, key)
            .enter()
            .append("circle")
            .attr("class", "dot")
            .attr("cx", function(d) {
                return x(d.m_mu);
            })
            .attr("cy", function(d) {
                return y(d.x);
            })
            .attr("r", 6)
            .on("mouseover", function(d) {
                d3.select("#tooltip")
                        .style("left", (width + 100) + "px")
                        .style("top", 0 + "px")
                        .classed("hidden", false);
            })
            .on("mouseout", function() {
                d3.select("#tooltip").classed("hidden", true);
            });

    // define zoom attr
    var zoom = d3.zoom()
            .scaleExtent([0.75, 20])
            .translateExtent([[-width/2, -height/2], [width*3/2, height*3/2]])
            .on("zoom", function() {
                // zoom g_dots group

                g_dots.attr("transform", d3.event.transform);
                //var curScale = g_dots.attr("transform").split(" ")[1].match(regex).map(function(v) { return parseFloat(v); })[0];
                circles.attr("r", 6 / d3.event.transform.k);

                gx.call(xAxis.scale(d3.event.transform.rescaleX(x)));
                gy.call(yAxis.scale(d3.event.transform.rescaleY(y)));

            });

    // create a rect for zooming
    svg.call(zm = zoom);

    // create a button for converting between the two scatters
    d3.select("body")
            .append("button")
            .text("turn")
            .on("click", function() {
                // convert between M0_x and M0_c, and change the dataset
                M0_x = !M0_x;

                if (M0_x) {
                    // redraw y axis
                    y.domain([d3.min(data1, function(d) { return d.x; }), d3.max(data1, function(d) { return d.x; })]);
                    gy.call(yAxis);

                    // redraw dots
                    g_dots.selectAll("circle")
                            .data(data1, key)
                            .attr("cx", function(d) {
                                return x(d.m_mu);
                            })
                            .attr("cy", function(d) {
                                return y(d.x);
                            });
                } else {
                    // redraw y axis
                    y.domain([d3.min(data1, function(d) { return d.c; }), d3.max(data1, function(d) { return d.c; })]);
                    gy.call(yAxis);

                    // redraw dots
                    g_dots.selectAll("circle")
                            .data(data1, key)
                            .attr("cx", function(d) {
                                return x(d.m_mu);
                            })
                            .attr("cy", function(d) {
                                return y(d.c);
                            });
                }

                //d3.selection.call(zoom.transform, d3.zoomIdentity);
                //d3.selection.call(zoom.scaleTo, d3.zoomIdentity);
            });

    /*
    d3.select("body")
            .append("button")
            .text("turn")
            .on("click", function() {
                d3.transition()
                        .duration(250)
                        .tween("zoom", svg.call(zoom.translate([0, 0]).scale(1).event));
            });
    */
</script>
</body>
</html>